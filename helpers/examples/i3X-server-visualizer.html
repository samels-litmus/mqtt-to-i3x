<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Litmus Automation i3X Server Experience</title>
<style>
  *{margin:0;padding:0;box-sizing:border-box}
  body{font-family:-apple-system,'SF Pro Text','Inter',system-ui,sans-serif;background:#0a0c10;color:#dfe2ec;height:100vh;overflow:hidden}
  canvas{position:absolute;top:0;left:0;width:100%;height:100%}

  /* HUD */
  .hud{position:fixed;z-index:100;pointer-events:none}
  .hud>*{pointer-events:auto}
  .hud-top{top:0;left:0;right:0;display:flex;align-items:center;padding:10px 20px;gap:12px;
    background:linear-gradient(to bottom,rgba(10,12,16,.92) 0%,rgba(10,12,16,.5) 80%,transparent 100%)}
  .logo{font-size:15px;font-weight:700;background:linear-gradient(135deg,#5b7fff,#a78bfa);
    -webkit-background-clip:text;-webkit-text-fill-color:transparent;white-space:nowrap}
  .dot{width:7px;height:7px;border-radius:50%;background:#34d399;box-shadow:0 0 8px #34d399;animation:blink 2.5s ease-in-out infinite}
  @keyframes blink{0%,100%{opacity:1}50%{opacity:.3}}
  .slab{font-size:11px;color:#6b7194;white-space:nowrap}
  .slab b{color:#dfe2ec;font-weight:600}
  .expand-btn{background:rgba(26,30,40,.9);border:1px solid #252a3a;border-radius:8px;padding:6px 14px;
    color:#6b7194;font-size:12px;cursor:pointer;transition:all .15s;backdrop-filter:blur(8px);white-space:nowrap;
    display:flex;align-items:center;gap:5px;font-family:inherit}
  .expand-btn:hover{border-color:#5b7fff;color:#dfe2ec;background:rgba(91,127,255,.1)}
  .expand-btn.active{border-color:#5b7fff;color:#5b7fff;background:rgba(91,127,255,.12)}
  .expand-btn.active:hover{border-color:#f472b6;color:#f472b6;background:rgba(244,114,182,.1)}
  .expand-btn #expandIcon{font-weight:700;font-size:14px;transition:transform .2s}
  .expand-btn.active #expandIcon{transform:rotate(45deg)}
  .search{margin-left:auto;background:rgba(26,30,40,.9);border:1px solid #252a3a;border-radius:8px;
    padding:7px 14px;color:#dfe2ec;font-size:13px;width:220px;outline:none;backdrop-filter:blur(8px)}
  .search:focus{border-color:#5b7fff}
  .search::placeholder{color:#6b7194}

  /* Tooltip */
  .tip{position:fixed;z-index:150;pointer-events:none;background:rgba(21,24,32,.95);backdrop-filter:blur(12px);
    border:1px solid #252a3a;border-radius:8px;padding:10px 14px;font-size:12px;max-width:280px;
    box-shadow:0 8px 32px rgba(0,0,0,.5);opacity:0;transition:opacity .12s;line-height:1.5}
  .tip.show{opacity:1}
  .tip .tname{font-weight:700;font-size:13px;margin-bottom:4px}
  .tip .tsub{color:#6b7194;font-size:10px;word-break:break-all}
  .tip .tval{font-family:'SF Mono',monospace;font-size:14px;font-weight:700;margin-top:6px}

  /* Overlay */
  .overlay{position:fixed;top:0;right:0;width:380px;max-width:90vw;height:100vh;
    background:rgba(21,24,32,.97);backdrop-filter:blur(20px);border-left:1px solid #252a3a;
    z-index:200;transform:translateX(100%);transition:transform .25s cubic-bezier(.4,0,.2,1);
    display:flex;flex-direction:column;box-shadow:-8px 0 40px rgba(0,0,0,.5)}
  .overlay.open{transform:translateX(0)}
  .ov-head{padding:16px 20px;border-bottom:1px solid #252a3a;display:flex;gap:12px;align-items:flex-start}
  .ov-title{font-size:16px;font-weight:700}
  .ov-sub{font-size:11px;color:#6b7194;word-break:break-all;margin-top:2px}
  .ov-close{margin-left:auto;background:none;border:none;color:#6b7194;font-size:18px;cursor:pointer;padding:4px}
  .ov-close:hover{color:#dfe2ec}
  .ov-body{flex:1;overflow-y:auto;padding:16px 20px}
  .ov-body::-webkit-scrollbar{width:5px}
  .ov-body::-webkit-scrollbar-thumb{background:#252a3a;border-radius:3px}
  .sec{margin-bottom:16px}
  .sec-title{font-size:10px;font-weight:700;text-transform:uppercase;letter-spacing:.6px;color:#6b7194;margin-bottom:8px}
  .kv{display:grid;grid-template-columns:auto 1fr;gap:3px 12px;font-size:12px}
  .kv-l{color:#6b7194}.kv-v{color:#dfe2ec;word-break:break-all;font-family:'SF Mono',monospace;font-size:11px}
  .big-val{background:#0a0c10;border-radius:8px;padding:14px 16px}
  .big-val .n{font-family:'SF Mono',monospace;font-size:32px;font-weight:800;
    background:linear-gradient(135deg,#22d3ee,#5b7fff);-webkit-background-clip:text;-webkit-text-fill-color:transparent}
  .big-val .t{font-size:10px;color:#6b7194;margin-top:4px}
  .json-blk{background:#0a0c10;border-radius:8px;padding:10px 14px;font-family:'SF Mono',monospace;
    font-size:11px;line-height:1.5;max-height:240px;overflow-y:auto;white-space:pre-wrap;word-break:break-all;color:#22d3ee}
  .rel-chain{display:flex;flex-direction:column;align-items:center;gap:4px}
  .rel-pill{padding:5px 12px;border-radius:6px;font-size:12px;cursor:pointer;transition:all .1s;
    max-width:100%;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
  .rel-pill:hover{transform:scale(1.03)}
  .rel-pill.par{background:rgba(245,158,11,.08);border:1px solid rgba(245,158,11,.25);color:#f59e0b}
  .rel-pill.me{background:rgba(91,127,255,.08);border:2px solid #5b7fff;color:#5b7fff;font-weight:700}
  .rel-pill.ch{background:rgba(52,211,153,.08);border:1px solid rgba(52,211,153,.25);color:#34d399}
  .rel-arr{color:#252a3a;font-size:10px}
  .rel-wrap{display:flex;flex-wrap:wrap;gap:5px;justify-content:center}

  .hint{position:fixed;bottom:16px;left:50%;transform:translateX(-50%);font-size:11px;color:#6b7194;
    padding:6px 16px;background:rgba(21,24,32,.8);backdrop-filter:blur(8px);border-radius:20px;
    border:1px solid #252a3a;z-index:100;transition:opacity .5s}

  /* Legend */
  .legend{position:fixed;bottom:16px;left:16px;z-index:100;font-size:10px;color:#6b7194;
    background:rgba(21,24,32,.85);backdrop-filter:blur(8px);border:1px solid #252a3a;
    border-radius:8px;padding:10px 14px;display:flex;flex-direction:column;gap:4px}
  .legend-row{display:flex;align-items:center;gap:6px}
  .legend-shape{width:12px;height:12px;flex-shrink:0}
</style>
</head>
<body>
<canvas id="c"></canvas>

<div class="hud hud-top">
  <span class="logo">Litmus Automation i3X Server Experience</span>
  <span class="dot"></span>
  <span class="slab">localhost:3000</span>
  <span class="slab" id="sInfo"></span>
  <button class="expand-btn" id="expandAll" title="Expand / Collapse all"><span id="expandIcon">+</span> Expand All</button>
  <input class="search" id="search" placeholder="Filter..." />
</div>

<div class="tip" id="tip"><div class="tname" id="tName"></div><div class="tsub" id="tSub"></div><div class="tval" id="tVal"></div></div>

<div class="overlay" id="overlay">
  <div class="ov-head">
    <div><div class="ov-title" id="oT"></div><div class="ov-sub" id="oS"></div></div>
    <button class="ov-close" id="oX">&times;</button>
  </div>
  <div class="ov-body" id="oB"></div>
</div>

<div class="hint" id="hint">Click to expand &middot; Drag to move &middot; Double-click leaf for details &middot; Scroll to zoom</div>

<div class="legend" id="legend">
  <div class="legend-row"><svg class="legend-shape" viewBox="0 0 12 12"><circle cx="6" cy="6" r="5" fill="none" stroke="#6b7194" stroke-width="1"/></svg> Container</div>
  <div class="legend-row"><svg class="legend-shape" viewBox="0 0 12 12"><rect x="1" y="2" width="10" height="8" rx="2" fill="none" stroke="#6b7194" stroke-width="1"/></svg> Data Tag</div>
  <div class="legend-row"><svg class="legend-shape" viewBox="0 0 12 12"><polygon points="6,1 11,6 6,11 1,6" fill="none" stroke="#6b7194" stroke-width="1"/></svg> Instrument</div>
  <div class="legend-row"><svg class="legend-shape" viewBox="0 0 12 12"><polygon points="6,1 10.5,3.5 10.5,8.5 6,11 1.5,8.5 1.5,3.5" fill="none" stroke="#6b7194" stroke-width="1"/></svg> Equipment</div>
</div>

<script>
const BASE = window.location.origin;
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');

// ===== CONSTANTS =====
const FRICTION = 0.92;
const SAND_FRICTION = 0.85;
const SPRING_K = 0.065;
const SPRING_DAMP = 0.7;
const COLLISION_STRENGTH = 0.3;
const SAND_COUNT = 60000;
const SAND_PUSH_RADIUS = 2.5;    // multiplier on node radius for sand displacement range
const SAND_PUSH_STRENGTH = 0.4;  // how hard nodes push sand
const SAND_DAMPING = 0.94;       // sand velocity friction per frame
const SAND_GRAIN_REPEL = 0.02;   // gentle grain-grain push (only nearby)
const SAND_SETTLE_SPEED = 0.003; // how fast grains drift back to home
const SAND_CELL = 60;            // spatial hash cell size

// ===== CANVAS =====
let W, H, dpr;
function resize() {
  dpr = window.devicePixelRatio || 1;
  W = window.innerWidth; H = window.innerHeight;
  canvas.width = W * dpr; canvas.height = H * dpr;
  canvas.style.width = W + 'px'; canvas.style.height = H + 'px';
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
}
window.addEventListener('resize', resize);
resize();

// ===== STATE =====
let camX = 0, camY = 0, zoom = 1;
let nodes = []; // all visible nodes on canvas
let nodeById = {}; // quick lookup by elementId
let namespaces = [], allObjects = [], types = [];
let byId = {}, byParent = {}, typesByNs = {};
let valCache = {};
let sandGrains = [];
let time = 0;

// Interaction
let dragNode = null, dragOffX = 0, dragOffY = 0;
let lastMX = 0, lastMY = 0, velX = 0, velY = 0;
let panDrag = false, panSX = 0, panSY = 0, panCX = 0, panCY = 0;
let hoverNode = null;
let clickStartTime = 0, clickStartNode = null;

// ===== NAMESPACE THEME =====
const nsColor = {
  'urn:proveit:enterprise-a': '#f472b6',
  'urn:proveit:enterprise-b': '#f59e0b',
  'urn:proveit:enterprise-c': '#a78bfa',
  'urn:proveit:abelara': '#22d3ee',
  'urn:proveit:fuuz': '#34d399',
  'urn:proveit:types': '#6b7194',
  'urn:vdma.org:OpcUaMachinery': '#5b7fff',
};
const nsIcon = {
  'urn:proveit:enterprise-a': '\u{1F3ED}',
  'urn:proveit:enterprise-b': '\u{1F37A}',
  'urn:proveit:enterprise-c': '\u{1F9EA}',
  'urn:proveit:abelara': '\u{1F3EA}',
  'urn:proveit:fuuz': '\u{1F4E1}',
  'urn:proveit:types': '\u{1F4D0}',
  'urn:vdma.org:OpcUaMachinery': '\u2699\uFE0F',
};

function getColor(nsUri) { return nsColor[nsUri] || '#6b7194'; }

// ===== SHAPE CLASSIFICATION =====
const equipmentTypes = new Set([
  'GlassFurnace','Forehearth','ISMachine','AnnealingLehr','BatchMixer','BatchCharger',
  'Bioreactor','Chromatography','Mixer','TFFSystem','StorageSilo','Tank','Vat',
  'Filler','Washer','Labeler','Packager','Sealer','Palletizer','CapLoader','Wrapper',
  'Robot','Workstation','ConvenienceStore'
]);
const instrumentTypes = new Set([
  'ProcessInstrument','EnvironmentalSensor','EdgeSensorValue','MachineryItemState',
  'MachineIdentificationType'
]);
const dataTypes = new Set([
  'GenericTag','ScalarProperty','DataPointTelem','Numeric','Item','Base','CountItem',
  'DecomposedComponent'
]);

// 'circle' | 'rect' | 'diamond' | 'hex'
function shapeFor(obj) {
  if (!obj) return 'circle';
  if (obj._isNs) return 'circle';
  if (obj._isType) return 'hex';
  if (obj.hasChildren) return 'circle';
  const t = obj.typeId || '';
  if (equipmentTypes.has(t)) return 'hex';
  if (instrumentTypes.has(t)) return 'diamond';
  if (dataTypes.has(t)) return 'rect';
  // KPI, OEE, WorkOrder, BatchAnalytics, CMMSAsset
  return 'rect';
}

// ===== SAND =====
function initSand() {
  sandGrains = [];
  for (let i = 0; i < SAND_COUNT; i++) {
    const dense = i < SAND_COUNT * 0.8;
    const hx = dense ? (Math.random() - 0.5) * 3000 : (Math.random() - 0.5) * 8000;
    const hy = dense ? (Math.random() - 0.5) * 2250 : (Math.random() - 0.5) * 6000;
    sandGrains.push({
      x: hx, y: hy,
      hx: hx, hy: hy,
      vx: 0, vy: 0,
      r: Math.random() * 1.1 + 0.3,
      a: Math.random() * 0.15 + 0.08,
    });
  }
}
initSand();

// ===== SAND SPATIAL HASH =====
let sandHash = {};
function sandHashKey(x, y) {
  return ((x / SAND_CELL) | 0) + ',' + ((y / SAND_CELL) | 0);
}
function buildSandHash() {
  sandHash = {};
  for (let i = 0; i < sandGrains.length; i++) {
    const g = sandGrains[i];
    const k = sandHashKey(g.x, g.y);
    if (!sandHash[k]) sandHash[k] = [];
    sandHash[k].push(i);
  }
}
function sandNear(wx, wy, range) {
  const result = [];
  const cx0 = ((wx - range) / SAND_CELL) | 0;
  const cx1 = ((wx + range) / SAND_CELL) | 0;
  const cy0 = ((wy - range) / SAND_CELL) | 0;
  const cy1 = ((wy + range) / SAND_CELL) | 0;
  for (let cx = cx0; cx <= cx1; cx++) {
    for (let cy = cy0; cy <= cy1; cy++) {
      const bucket = sandHash[cx + ',' + cy];
      if (bucket) for (const idx of bucket) result.push(idx);
    }
  }
  return result;
}

// ===== SAND PHYSICS =====
function sandPhysics() {
  buildSandHash();

  // Node -> sand interaction
  for (const n of nodes) {
    if (n.removing) continue;
    const speed = Math.sqrt(n.vx * n.vx + n.vy * n.vy);
    const pushR = n.radius * SAND_PUSH_RADIUS;
    const nearby = sandNear(n.x, n.y, pushR);
    for (const idx of nearby) {
      const g = sandGrains[idx];
      const dx = g.x - n.x;
      const dy = g.y - n.y;
      const dist = Math.sqrt(dx * dx + dy * dy) || 0.1;
      if (dist < pushR) {
        const overlap = 1 - dist / pushR;
        const force = overlap * overlap * SAND_PUSH_STRENGTH;
        const nx = dx / dist;
        const ny = dy / dist;
        g.vx += nx * force * (1 + speed * 0.5);
        g.vy += ny * force * (1 + speed * 0.5);
        g.vx += n.vx * overlap * 0.15;
        g.vy += n.vy * overlap * 0.15;
      }
    }
  }

  // Grain-grain soft repulsion (sampled for performance)
  const step = Math.max(1, (sandGrains.length / 800) | 0);
  for (let i = 0; i < sandGrains.length; i += step) {
    const g = sandGrains[i];
    const nearby = sandNear(g.x, g.y, 4);
    for (const jIdx of nearby) {
      if (jIdx === i) continue;
      const h = sandGrains[jIdx];
      const dx = h.x - g.x;
      const dy = h.y - g.y;
      const dist = Math.sqrt(dx * dx + dy * dy) || 0.1;
      if (dist < 3) {
        const push = (3 - dist) * SAND_GRAIN_REPEL;
        const nx = dx / dist;
        const ny = dy / dist;
        g.vx -= nx * push;
        g.vy -= ny * push;
        h.vx += nx * push;
        h.vy += ny * push;
      }
    }
  }

  // Update grain positions
  for (const g of sandGrains) {
    g.vx += (g.hx - g.x) * SAND_SETTLE_SPEED;
    g.vy += (g.hy - g.y) * SAND_SETTLE_SPEED;
    g.vx *= SAND_DAMPING;
    g.vy *= SAND_DAMPING;
    g.x += g.vx;
    g.y += g.vy;
    if (Math.abs(g.vx) < 0.001) g.vx = 0;
    if (Math.abs(g.vy) < 0.001) g.vy = 0;
  }
}

// ===== NODE FACTORY =====
function makeNode(obj, x, y, depth, parentNode) {
  const isNs = !!obj._isNs;
  const isType = !!obj._isType;
  const nsObjCount = isNs ? allObjects.filter(o => o.namespaceUri === obj.uri).length : 0;
  const nsTypeCount = isNs ? (typesByNs[obj.uri] || []).length : 0;
  const hasKids = isNs ? (nsObjCount + nsTypeCount > 0) : isType ? false : !!obj.hasChildren;
  const childCount = isNs ? (nsObjCount + nsTypeCount) :
    (byParent[obj.elementId] || []).length;

  // Size based on depth and children
  let radius;
  if (isNs) radius = 42;
  else if (depth === 0) radius = 36;
  else if (hasKids) radius = Math.max(16, 28 - depth * 3 + Math.min(childCount, 20) * 0.3);
  else radius = Math.max(10, 16 - depth * 1.5);

  const nsUri = isNs ? obj.uri : obj.namespaceUri;

  return {
    obj,
    id: isNs ? 'ns:' + obj.uri : (isType ? obj.elementId : obj.elementId),
    isType,
    isNs,
    x, y,
    vx: 0, vy: 0,
    tx: x, ty: y, // spring target
    radius,
    depth,
    shape: shapeFor(obj),
    color: getColor(nsUri),
    nsUri,
    hasKids,
    expanded: false,
    childNodes: [],
    parentNode: parentNode || null,
    entering: true, // for spring animation
    removing: false,
    removeProgress: 0,
  };
}

// ===== DATA LOADING =====
async function load() {
  const [ns, obj] = await Promise.all([
    fetch(BASE + '/namespaces').then(r => r.json()),
    fetch(BASE + '/objects').then(r => r.json()),
  ]);
  namespaces = ns;
  allObjects = obj;
  byId = {}; byParent = {};
  for (const o of allObjects) {
    byId[o.elementId] = o;
    const p = (!o.parentId || o.parentId === '/') ? '__root__' : o.parentId;
    (byParent[p] || (byParent[p] = [])).push(o);
  }

  const tp = await Promise.all(namespaces.map(n =>
    fetch(BASE + '/objecttypes?namespaceUri=' + encodeURIComponent(n.uri)).then(r => r.json())
  ));
  namespaces.forEach((n, i) => { typesByNs[n.uri] = tp[i]; });
  types = tp.flat();

  document.getElementById('sInfo').innerHTML = `<b>${allObjects.length.toLocaleString()}</b> objects &middot; <b>${types.length}</b> types &middot; <b>${namespaces.length}</b> namespaces`;

  // Create namespace root nodes
  const count = namespaces.length;
  const angleStep = (Math.PI * 2) / count;
  const ringR = 140;
  namespaces.forEach((ns, i) => {
    const a = angleStep * i - Math.PI / 2;
    const nx = Math.cos(a) * ringR;
    const ny = Math.sin(a) * ringR;
    const node = makeNode({ ...ns, _isNs: true }, 0, 0, 0, null);
    node.tx = nx; node.ty = ny;
    nodes.push(node);
    nodeById[node.id] = node;
  });

  prefetchValues();
}

async function prefetchValues() {
  const leafIds = allObjects.filter(o => !o.hasChildren).map(o => o.elementId);
  for (let i = 0; i < leafIds.length; i += 100) {
    const batch = leafIds.slice(i, i + 100);
    try {
      const data = await fetch(BASE + '/objects/value', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ elementIds: batch }),
      }).then(r => r.json());
      for (const [eid, val] of Object.entries(data)) {
        if (val?.data?.[0]) valCache[eid] = val.data[0];
      }
    } catch (e) {}
  }
}

async function getValue(eid) {
  if (valCache[eid]) return valCache[eid];
  try {
    const data = await fetch(BASE + '/objects/value', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ elementIds: [eid] }),
    }).then(r => r.json());
    if (data[eid]?.data?.[0]) { valCache[eid] = data[eid].data[0]; return valCache[eid]; }
  } catch (e) {}
  return null;
}

// ===== EXPAND / COLLAPSE =====
function expandNode(node) {
  if (node.expanded || !node.hasKids) return;
  node.expanded = true;

  let children;
  if (node.isNs) {
    // Root objects for this namespace (parentId missing, "/", or not in dataset)
    const nsObjs = allObjects.filter(o => o.namespaceUri === node.obj.uri);
    const roots = nsObjs.filter(o => !o.parentId || o.parentId === '/' || !byId[o.parentId]);
    // Also include object types as virtual child nodes
    const nsTypes = (typesByNs[node.obj.uri] || []).map(t => ({
      ...t, _isType: true, displayName: t.displayName, elementId: 'type:' + t.elementId,
      hasChildren: false, namespaceUri: t.namespaceUri,
    }));
    children = [...roots, ...nsTypes];
  } else {
    children = byParent[node.obj.elementId] || [];
  }

  // Sort: containers first, then types, then alpha
  children = [...children].sort((a, b) => {
    if (a.hasChildren !== b.hasChildren) return a.hasChildren ? -1 : 1;
    if (!!a._isType !== !!b._isType) return a._isType ? 1 : -1;
    return a.displayName.localeCompare(b.displayName);
  });

  const count = children.length;
  if (count === 0) { node.expanded = false; return; }

  // Radial layout
  const baseR = node.radius + 30 + Math.min(count, 30) * 3.5;
  const angleStep = (Math.PI * 2) / Math.max(count, 1);
  // Start angle: point away from parent if we have one
  let startAngle = -Math.PI / 2;
  if (node.parentNode) {
    startAngle = Math.atan2(node.y - node.parentNode.y, node.x - node.parentNode.x);
  }

  children.forEach((child, i) => {
    const a = startAngle + angleStep * i + (Math.random() - 0.5) * 0.15;
    const r = baseR + (Math.random() - 0.5) * 12;
    const tx = node.x + Math.cos(a) * r;
    const ty = node.y + Math.sin(a) * r;

    const cn = makeNode(child, node.x, node.y, node.depth + 1, node);
    cn.tx = tx; cn.ty = ty;
    cn.entering = true;

    node.childNodes.push(cn);
    nodes.push(cn);
    nodeById[cn.id] = cn;
  });
}

function collapseNode(node) {
  if (!node.expanded) return;
  node.expanded = false;

  // Recursively collapse children first
  for (const cn of node.childNodes) {
    collapseNode(cn);
    cn.removing = true;
    cn.tx = node.x;
    cn.ty = node.y;
  }
}

function cleanRemovedNodes() {
  const toRemove = [];
  for (const n of nodes) {
    if (n.removing) {
      const dx = n.x - n.tx;
      const dy = n.y - n.ty;
      if (Math.sqrt(dx * dx + dy * dy) < 3) {
        toRemove.push(n);
      }
    }
  }
  for (const n of toRemove) {
    const idx = nodes.indexOf(n);
    if (idx !== -1) nodes.splice(idx, 1);
    delete nodeById[n.id];
    if (n.parentNode) {
      const ci = n.parentNode.childNodes.indexOf(n);
      if (ci !== -1) n.parentNode.childNodes.splice(ci, 1);
    }
  }
}

// ===== PHYSICS =====
function physics() {
  for (const n of nodes) {
    if (n === dragNode) continue;

    // Spring toward target
    const dx = n.tx - n.x;
    const dy = n.ty - n.y;
    const fx = dx * SPRING_K;
    const fy = dy * SPRING_K;

    n.vx = (n.vx + fx) * SPRING_DAMP;
    n.vy = (n.vy + fy) * SPRING_DAMP;

    // Sand friction for free-moving nodes
    if (Math.abs(dx) < 1 && Math.abs(dy) < 1) {
      n.vx *= SAND_FRICTION;
      n.vy *= SAND_FRICTION;
    }

    n.x += n.vx;
    n.y += n.vy;

    if (Math.abs(n.vx) < 0.005) n.vx = 0;
    if (Math.abs(n.vy) < 0.005) n.vy = 0;
  }

  // Soft collision between non-removing nodes
  for (let i = 0; i < nodes.length; i++) {
    if (nodes[i].removing) continue;
    for (let j = i + 1; j < nodes.length; j++) {
      if (nodes[j].removing) continue;
      const a = nodes[i], b = nodes[j];
      const dx = b.x - a.x;
      const dy = b.y - a.y;
      const dist = Math.sqrt(dx * dx + dy * dy) || 0.1;
      const minDist = a.radius + b.radius + 4;
      if (dist < minDist) {
        const push = (minDist - dist) * COLLISION_STRENGTH;
        const nx = dx / dist, ny = dy / dist;
        if (a !== dragNode) { a.x -= nx * push * 0.5; a.y -= ny * push * 0.5; a.tx -= nx * push * 0.15; a.ty -= ny * push * 0.15; }
        if (b !== dragNode) { b.x += nx * push * 0.5; b.y += ny * push * 0.5; b.tx += nx * push * 0.15; b.ty += ny * push * 0.15; }
      }
    }
  }

  // When dragging, update children targets relative to drag
  if (dragNode && dragNode.expanded) {
    updateChildTargets(dragNode);
  }

  cleanRemovedNodes();
}

function updateChildTargets(node) {
  // Recompute children target positions relative to node's current position
  const children = node.childNodes;
  if (children.length === 0) return;
  const count = children.length;
  const baseR = node.radius + 30 + Math.min(count, 30) * 3.5;

  let startAngle = -Math.PI / 2;
  if (node.parentNode) {
    startAngle = Math.atan2(node.y - node.parentNode.y, node.x - node.parentNode.x);
  }

  const angleStep = (Math.PI * 2) / Math.max(count, 1);
  children.forEach((cn, i) => {
    // Preserve the angle the child was placed at, but update center
    const oldDx = cn.tx - (node.tx);
    const oldDy = cn.ty - (node.ty);
    // Shift targets by the delta of the parent's movement
    cn.tx = node.x + oldDx;
    cn.ty = node.y + oldDy;
    if (cn.expanded) updateChildTargets(cn);
  });
}

// ===== COORD TRANSFORMS =====
function w2s(wx, wy) { return [(wx - camX) * zoom + W / 2, (wy - camY) * zoom + H / 2]; }
function s2w(sx, sy) { return [(sx - W / 2) / zoom + camX, (sy - H / 2) / zoom + camY]; }

// ===== DRAWING =====
function drawSand() {
  for (const g of sandGrains) {
    const sx = (g.x - camX) * zoom + W / 2;
    const sy = (g.y - camY) * zoom + H / 2;
    if (sx < -5 || sx > W + 5 || sy < -5 || sy > H + 5) continue;
    ctx.beginPath();
    ctx.arc(sx, sy, g.r * zoom, 0, Math.PI * 2);
    ctx.fillStyle = `rgba(194,178,148,${g.a})`;
    ctx.fill();
  }
}

function drawLines() {
  for (const n of nodes) {
    if (!n.parentNode || n.removing) continue;
    const p = n.parentNode;
    const [px, py] = w2s(p.x, p.y);
    const [nx, ny] = w2s(n.x, n.y);

    // Skip if both off screen
    if (px < -100 && nx < -100) continue;
    if (px > W + 100 && nx > W + 100) continue;
    if (py < -100 && ny < -100) continue;
    if (py > H + 100 && ny > H + 100) continue;

    const alpha = Math.max(0.04, 0.2 - n.depth * 0.03);
    ctx.beginPath();
    ctx.moveTo(px, py);
    // Gentle curve
    const mx = (px + nx) / 2 + (py - ny) * 0.08;
    const my = (py + ny) / 2 + (nx - px) * 0.08;
    ctx.quadraticCurveTo(mx, my, nx, ny);
    ctx.strokeStyle = n.color + hexAlpha(alpha);
    ctx.lineWidth = Math.max(0.5, (1.5 - n.depth * 0.15) * zoom);
    ctx.stroke();
  }
}

function drawNode(n) {
  const [sx, sy] = w2s(n.x, n.y);
  const sr = n.radius * zoom;

  // Culling
  if (sx + sr < -20 || sx - sr > W + 20 || sy + sr < -20 || sy - sr > H + 20) return;

  const isHover = n === hoverNode && !n.removing;
  const isDrag = n === dragNode;
  const alpha = n.removing ? 0.3 : 1;

  // Expanded halo
  if (n.expanded && !n.removing) {
    const haloR = sr + 8 * zoom;
    const grad = ctx.createRadialGradient(sx, sy, sr * 0.8, sx, sy, haloR);
    grad.addColorStop(0, n.color + '18');
    grad.addColorStop(1, n.color + '00');
    ctx.beginPath();
    ctx.arc(sx, sy, haloR, 0, Math.PI * 2);
    ctx.fillStyle = grad;
    ctx.fill();
  }

  // Pulsing ring for expandable non-expanded
  if (n.hasKids && !n.expanded && !n.removing) {
    const pulseR = sr + (3 + Math.sin(time * 2 + n.x * 0.01) * 2) * zoom;
    ctx.beginPath();
    ctx.arc(sx, sy, pulseR, 0, Math.PI * 2);
    ctx.strokeStyle = n.color + '30';
    ctx.lineWidth = 1 * zoom;
    ctx.stroke();
  }

  // Shadow
  if (isDrag) {
    ctx.shadowColor = 'rgba(0,0,0,.45)';
    ctx.shadowBlur = 16 * zoom;
    ctx.shadowOffsetY = 4 * zoom;
  }

  // Shape fill
  const fillColor = isHover ? lighten(n.color, 0.15) : n.color;
  const fillAlpha = n.isNs ? '30' : (n.hasKids ? '22' : '35');
  const strokeAlpha = isHover ? 'aa' : '66';

  ctx.beginPath();
  drawShape(ctx, n.shape, sx, sy, sr);
  ctx.fillStyle = fillColor + fillAlpha;
  ctx.fill();
  ctx.strokeStyle = fillColor + strokeAlpha;
  ctx.lineWidth = (isHover || isDrag ? 2 : 1.2) * zoom;
  ctx.stroke();

  ctx.shadowColor = 'transparent';
  ctx.shadowBlur = 0;
  ctx.shadowOffsetY = 0;

  // Label
  if (sr > 8) {
    const name = n.isNs ? n.obj.displayName : n.obj.displayName;
    const fontSize = Math.max(8, Math.min(13, sr * 0.38)) * zoom;
    ctx.font = `600 ${fontSize}px -apple-system, system-ui`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';

    // Icon for namespaces
    if (n.isNs && sr > 16) {
      const iconSize = sr * 0.5;
      ctx.font = `${iconSize}px -apple-system, system-ui`;
      ctx.fillStyle = '#dfe2ec';
      ctx.fillText(nsIcon[n.obj.uri] || '', sx, sy - fontSize * 0.5);
      ctx.font = `600 ${fontSize}px -apple-system, system-ui`;
      ctx.fillStyle = n.color;
      ctx.fillText(truncText(name, ctx, sr * 1.6 * zoom), sx, sy + iconSize * 0.45);
    } else if (n.isType && sr > 10) {
      // Type nodes: show name + small "type" label
      ctx.fillStyle = n.color;
      ctx.fillText(truncText(name, ctx, sr * 1.8 * zoom), sx, sy - fontSize * 0.3);
      const tSize = Math.max(6, fontSize * 0.65);
      ctx.font = `500 ${tSize}px -apple-system, system-ui`;
      ctx.fillStyle = n.color + '88';
      ctx.fillText('TYPE', sx, sy + fontSize * 0.6);
    } else {
      ctx.fillStyle = `rgba(223,226,236,${alpha})`;
      ctx.fillText(truncText(name, ctx, sr * 1.8 * zoom), sx, sy);
    }

    // Value display for leaves
    if (!n.hasKids && !n.isNs && sr > 12) {
      const cached = valCache[n.obj.elementId];
      if (cached && cached.value !== null && cached.value !== undefined) {
        const v = cached.value;
        let vStr = '';
        if (typeof v === 'number') vStr = formatNum(v);
        else if (typeof v === 'string' && v.length < 12) vStr = v;
        else if (typeof v === 'object') vStr = '{...}';
        if (vStr) {
          const vSize = Math.max(7, fontSize * 0.8);
          ctx.font = `700 ${vSize}px 'SF Mono', monospace`;
          ctx.fillStyle = n.color + 'cc';
          ctx.fillText(truncText(vStr, ctx, sr * 1.6 * zoom), sx, sy + fontSize * 0.9);
        }
      }
    }
  }

  // "+" indicator for expandable
  if (n.hasKids && !n.expanded && !n.removing && sr > 6) {
    const ps = Math.max(6, sr * 0.25);
    ctx.font = `700 ${ps}px -apple-system, system-ui`;
    ctx.fillStyle = n.color + '88';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('+', sx + sr * 0.65, sy - sr * 0.55);
  }
}

function drawShape(ctx, shape, sx, sy, r) {
  switch (shape) {
    case 'circle':
      ctx.arc(sx, sy, r, 0, Math.PI * 2);
      break;
    case 'rect': {
      const rr = r * 0.75;
      const cr = r * 0.2;
      ctx.moveTo(sx - rr + cr, sy - rr);
      ctx.lineTo(sx + rr - cr, sy - rr);
      ctx.arcTo(sx + rr, sy - rr, sx + rr, sy - rr + cr, cr);
      ctx.lineTo(sx + rr, sy + rr - cr);
      ctx.arcTo(sx + rr, sy + rr, sx + rr - cr, sy + rr, cr);
      ctx.lineTo(sx - rr + cr, sy + rr);
      ctx.arcTo(sx - rr, sy + rr, sx - rr, sy + rr - cr, cr);
      ctx.lineTo(sx - rr, sy - rr + cr);
      ctx.arcTo(sx - rr, sy - rr, sx - rr + cr, sy - rr, cr);
      break;
    }
    case 'diamond':
      ctx.moveTo(sx, sy - r);
      ctx.lineTo(sx + r * 0.75, sy);
      ctx.lineTo(sx, sy + r);
      ctx.lineTo(sx - r * 0.75, sy);
      ctx.closePath();
      break;
    case 'hex': {
      for (let i = 0; i < 6; i++) {
        const a = (Math.PI / 3) * i - Math.PI / 6;
        const px = sx + Math.cos(a) * r;
        const py = sy + Math.sin(a) * r;
        if (i === 0) ctx.moveTo(px, py);
        else ctx.lineTo(px, py);
      }
      ctx.closePath();
      break;
    }
  }
}

// ===== HIT TEST =====
function hitTest(mx, my) {
  const [wx, wy] = s2w(mx, my);
  // Reverse for top-most
  for (let i = nodes.length - 1; i >= 0; i--) {
    const n = nodes[i];
    if (n.removing) continue;
    const dx = wx - n.x, dy = wy - n.y;
    if (dx * dx + dy * dy <= n.radius * n.radius) return n;
  }
  return null;
}

// ===== TOOLTIP =====
const tip = document.getElementById('tip');
const tName = document.getElementById('tName');
const tSub = document.getElementById('tSub');
const tVal = document.getElementById('tVal');
let tipVisible = false;

function showTip(node, mx, my) {
  if (!node || dragNode || node.removing) { hideTip(); return; }
  tName.textContent = node.isNs ? node.obj.displayName : node.obj.displayName;
  tSub.textContent = node.isNs ? node.obj.uri : node.obj.elementId;

  let vStr = '';
  if (node.isType) {
    const instCount = allObjects.filter(o => o.typeId === node.obj.elementId?.replace('type:','')).length;
    vStr = 'Type definition \u00B7 ' + instCount + ' instances';
  } else if (!node.isNs) {
    const cached = valCache[node.obj.elementId];
    if (cached?.value !== null && cached?.value !== undefined) {
      const v = cached.value;
      if (typeof v === 'number') vStr = formatNum(v);
      else if (typeof v === 'string') vStr = v.length > 60 ? v.slice(0, 60) + '...' : v;
      else if (typeof v === 'object') vStr = JSON.stringify(v).slice(0, 80) + '...';
    }
    if (node.hasKids) {
      const cc = (byParent[node.obj.elementId] || []).length;
      vStr = cc + ' children' + (node.expanded ? ' (expanded)' : '');
    }
  } else {
    const objCount = allObjects.filter(o => o.namespaceUri === node.obj.uri).length;
    const typeCount = (typesByNs[node.obj.uri] || []).length;
    vStr = objCount.toLocaleString() + ' objects \u00B7 ' + typeCount + ' types';
  }
  tVal.textContent = vStr;
  tVal.style.color = node.color;

  tip.style.left = Math.min(mx + 16, W - 300) + 'px';
  tip.style.top = Math.min(my + 16, H - 100) + 'px';
  tip.classList.add('show');
  tipVisible = true;
}

function hideTip() {
  if (!tipVisible) return;
  tip.classList.remove('show');
  tipVisible = false;
}

// ===== OVERLAY =====
function openOverlay(obj) {
  const ov = document.getElementById('overlay');
  document.getElementById('oT').textContent = obj.displayName;
  document.getElementById('oS').textContent = obj.elementId;
  document.getElementById('oB').innerHTML = '<div style="color:#6b7194;font-size:12px;padding:20px;text-align:center;">Loading...</div>';
  ov.classList.add('open');
  fillOverlay(obj);
}

async function fillOverlay(obj) {
  const body = document.getElementById('oB');
  const children = byParent[obj.elementId] || [];
  const parent = obj.parentId ? byId[obj.parentId] : null;
  const siblings = parent ? (byParent[parent.elementId] || []).filter(s => s.elementId !== obj.elementId) : [];
  const vqt = await getValue(obj.elementId);

  let h = '';
  if (vqt) {
    const v = vqt.value;
    h += '<div class="sec"><div class="sec-title">Current Value</div>';
    if (typeof v === 'number') {
      h += `<div class="big-val"><div class="n">${formatNum(v)}</div><div class="t">${esc(vqt.timestamp||'')}</div></div>`;
    } else if (typeof v === 'object' && v !== null) {
      h += `<div class="json-blk">${synHL(JSON.stringify(v, null, 2))}</div>`;
      h += `<div style="font-size:10px;color:#6b7194;margin-top:4px;">${esc(vqt.timestamp||'')}</div>`;
    } else if (v !== null && v !== undefined) {
      h += `<div class="big-val"><div class="n" style="font-size:18px;">${esc(String(v))}</div><div class="t">${esc(vqt.timestamp||'')}</div></div>`;
    }
    h += '</div>';
  }

  h += '<div class="sec"><div class="sec-title">Properties</div><div class="kv">';
  h += kv('Element ID', obj.elementId) + kv('Type', obj.typeId || '\u2014');
  h += kv('Namespace', obj.namespaceUri) + kv('Children', obj.hasChildren ? String(children.length) : 'none');
  h += kv('Composition', obj.isComposition ? 'Yes' : 'No');
  if (parent) h += kv('Parent', parent.displayName);
  h += '</div></div>';

  h += '<div class="sec"><div class="sec-title">Relationships</div><div class="rel-chain">';
  if (parent) {
    h += `<div class="rel-pill par" data-go="${esc(parent.elementId)}">\u2191 ${esc(parent.displayName)}</div>`;
    h += '<div class="rel-arr">\u25BC</div>';
  }
  h += `<div class="rel-pill me">${esc(obj.displayName)}</div>`;
  if (children.length > 0) {
    h += '<div class="rel-arr">\u25BC</div><div class="rel-wrap">';
    for (const c of children.slice(0, 15))
      h += `<div class="rel-pill ch" data-go="${esc(c.elementId)}">${esc(c.displayName)}</div>`;
    if (children.length > 15) h += `<div style="font-size:10px;color:#6b7194;">+${children.length-15}</div>`;
    h += '</div>';
  }
  h += '</div></div>';

  if (siblings.length > 0) {
    h += `<div class="sec"><div class="sec-title">Siblings (${siblings.length})</div><div class="rel-wrap">`;
    for (const s of siblings.slice(0, 15))
      h += `<div class="rel-pill ch" data-go="${esc(s.elementId)}" style="border-color:rgba(91,127,255,.2);color:#5b7fff;background:rgba(91,127,255,.05);">${esc(s.displayName)}</div>`;
    if (siblings.length > 15) h += `<div style="font-size:10px;color:#6b7194;">+${siblings.length-15}</div>`;
    h += '</div></div>';
  }

  body.innerHTML = h;
  body.querySelectorAll('[data-go]').forEach(el => {
    el.onclick = () => { const o = byId[el.dataset.go]; if (o) openOverlay(o); };
  });
}

function openTypeOverlay(typeObj) {
  const realId = (typeObj.elementId || '').replace('type:', '');
  const ov = document.getElementById('overlay');
  document.getElementById('oT').textContent = typeObj.displayName;
  document.getElementById('oS').textContent = typeObj.namespaceUri + ' \u00B7 ' + realId;
  const body = document.getElementById('oB');

  const schema = typeObj.schema || {};
  const props = schema.properties || {};
  const required = schema.required || [];
  const instances = allObjects.filter(o => o.typeId === realId);

  let h = '<div class="sec"><div class="sec-title">Schema Properties</div>';
  if (Object.keys(props).length > 0) {
    h += '<div class="kv">';
    for (const [name, def] of Object.entries(props)) {
      const req = required.includes(name) ? ' *' : '';
      h += `<span class="kv-l">${esc(name)}${req}</span><span class="kv-v">${esc(def.type || 'any')}${def.description ? ' \u2014 ' + esc(def.description) : ''}</span>`;
    }
    h += '</div>';
  } else {
    h += '<div style="color:#6b7194;font-size:12px;">Generic (untyped) schema</div>';
  }
  h += '</div>';

  h += `<div class="sec"><div class="sec-title">Instances (${instances.length})</div>`;
  h += '<div class="rel-wrap">';
  for (const inst of instances.slice(0, 20)) {
    h += `<div class="rel-pill ch" data-go="${esc(inst.elementId)}">${esc(inst.displayName)}</div>`;
  }
  if (instances.length > 20) h += `<div style="font-size:10px;color:#6b7194;">+${instances.length - 20} more</div>`;
  h += '</div></div>';

  body.innerHTML = h;
  ov.classList.add('open');
  body.querySelectorAll('[data-go]').forEach(el => {
    el.onclick = () => { const o = byId[el.dataset.go]; if (o) openOverlay(o); };
  });
}

function closeOverlay() { document.getElementById('overlay').classList.remove('open'); }
document.getElementById('oX').onclick = closeOverlay;

// ===== INPUT =====
canvas.addEventListener('mousedown', e => {
  hideTip();
  const n = hitTest(e.clientX, e.clientY);
  clickStartTime = Date.now();
  clickStartNode = n;

  if (n) {
    dragNode = n;
    const [wx, wy] = s2w(e.clientX, e.clientY);
    dragOffX = wx - n.x;
    dragOffY = wy - n.y;
    lastMX = e.clientX; lastMY = e.clientY;
    velX = 0; velY = 0;
    canvas.style.cursor = 'grabbing';
  } else {
    panDrag = true;
    panSX = e.clientX; panSY = e.clientY;
    panCX = camX; panCY = camY;
    canvas.style.cursor = 'grabbing';
  }
});

canvas.addEventListener('mousemove', e => {
  if (dragNode) {
    const [wx, wy] = s2w(e.clientX, e.clientY);
    const nx = wx - dragOffX, ny = wy - dragOffY;
    velX = (e.clientX - lastMX) / zoom;
    velY = (e.clientY - lastMY) / zoom;
    lastMX = e.clientX; lastMY = e.clientY;
    dragNode.x = nx; dragNode.y = ny;
    dragNode.tx = nx; dragNode.ty = ny;
    hideTip();
  } else if (panDrag) {
    camX = panCX - (e.clientX - panSX) / zoom;
    camY = panCY - (e.clientY - panSY) / zoom;
    hideTip();
  } else {
    const n = hitTest(e.clientX, e.clientY);
    hoverNode = n;
    canvas.style.cursor = n ? 'pointer' : 'default';
    if (n) showTip(n, e.clientX, e.clientY);
    else hideTip();
  }
});

canvas.addEventListener('mouseup', e => {
  const elapsed = Date.now() - clickStartTime;
  const n = hitTest(e.clientX, e.clientY);
  const wasDrag = dragNode && (Math.abs(velX) > 1 || Math.abs(velY) > 1 || elapsed > 250);

  if (dragNode) {
    if (wasDrag) {
      // Inertia throw
      dragNode.vx = velX * 0.6;
      dragNode.vy = velY * 0.6;
      // Also update target so it stays where thrown
      dragNode.tx = dragNode.x + dragNode.vx * 8;
      dragNode.ty = dragNode.y + dragNode.vy * 8;
    } else if (n === clickStartNode && n) {
      // Click (not drag): toggle expand
      if (n.hasKids) {
        if (n.expanded) collapseNode(n);
        else expandNode(n);
      }
    }
    dragNode = null;
  }
  panDrag = false;
  canvas.style.cursor = hoverNode ? 'pointer' : 'default';
});

canvas.addEventListener('dblclick', e => {
  const n = hitTest(e.clientX, e.clientY);
  if (!n || n.removing) return;
  if (n.isType) { openTypeOverlay(n.obj); return; }
  if (!n.hasKids && !n.isNs) { openOverlay(n.obj); }
});

canvas.addEventListener('wheel', e => {
  e.preventDefault();
  const oldZ = zoom;
  zoom = Math.max(0.15, Math.min(4, zoom - e.deltaY * 0.001));
  const [wx, wy] = [(e.clientX - W / 2) / oldZ + camX, (e.clientY - H / 2) / oldZ + camY];
  camX = wx - (e.clientX - W / 2) / zoom;
  camY = wy - (e.clientY - H / 2) / zoom;
}, { passive: false });

document.addEventListener('keydown', e => {
  if (e.key === 'Escape') closeOverlay();
});

// Search
let searchTimer;
document.getElementById('search').addEventListener('input', e => {
  clearTimeout(searchTimer);
  searchTimer = setTimeout(() => {
    const f = e.target.value.trim().toLowerCase();
    if (!f) {
      // Reset highlight
      for (const n of nodes) n._highlight = false;
      return;
    }
    for (const n of nodes) {
      const name = n.isNs ? n.obj.displayName : n.obj.displayName;
      const eid = n.isNs ? n.obj.uri : n.obj.elementId;
      n._highlight = name.toLowerCase().includes(f) || eid.toLowerCase().includes(f);
    }
  }, 150);
});

// ===== EXPAND ALL =====
let expandAllActive = false;
let expandQueue = [];
let expandTimer = null;

document.getElementById('expandAll').addEventListener('click', () => {
  const btn = document.getElementById('expandAll');

  if (expandAllActive) {
    // Collapse everything back
    expandAllActive = false;
    btn.classList.remove('active');
    btn.innerHTML = '<span id="expandIcon">+</span> Expand All';
    clearInterval(expandTimer);
    expandQueue = [];
    // Collapse all namespace nodes (which recursively collapses everything)
    for (const n of [...nodes]) {
      if (n.isNs && n.expanded) collapseNode(n);
    }
  } else {
    // Expand progressively: level by level
    expandAllActive = true;
    btn.classList.add('active');
    btn.innerHTML = '<span id="expandIcon">+</span> Collapse All';

    // Start by expanding all namespace nodes
    for (const n of nodes) {
      if (n.isNs && !n.expanded) expandNode(n);
    }

    // Then queue subsequent levels with staggered timing
    let depth = 1;
    expandTimer = setInterval(() => {
      if (!expandAllActive) { clearInterval(expandTimer); return; }
      const toExpand = nodes.filter(n => !n.removing && n.hasKids && !n.expanded && n.depth === depth);
      if (toExpand.length === 0) {
        // No more to expand at this depth - try next
        depth++;
        const anyLeft = nodes.some(n => !n.removing && n.hasKids && !n.expanded && n.depth >= depth);
        if (!anyLeft) {
          clearInterval(expandTimer);
        }
        return;
      }
      // Expand a batch at this depth (cap to avoid frame drops)
      const batch = toExpand.slice(0, 15);
      for (const n of batch) expandNode(n);
      // Stay at this depth if there are more
      if (toExpand.length <= 15) depth++;
    }, 350);
  }
});

// ===== RENDER LOOP =====
function frame() {
  time += 0.016;
  physics();
  sandPhysics();

  ctx.clearRect(0, 0, W, H);

  // Background
  ctx.fillStyle = '#0a0c10';
  ctx.fillRect(0, 0, W, H);

  // Table glow
  const grad = ctx.createRadialGradient(W / 2, H / 2, 0, W / 2, H / 2, Math.max(W, H) * 0.6);
  grad.addColorStop(0, 'rgba(40,35,28,0.08)');
  grad.addColorStop(1, 'rgba(10,12,16,0)');
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, W, H);

  drawSand();
  drawLines();

  // Sort: draw drag node last
  const sorted = [...nodes].sort((a, b) => {
    if (a === dragNode) return 1;
    if (b === dragNode) return -1;
    return a.depth - b.depth;
  });

  for (const n of sorted) {
    // Search highlight
    if (n._highlight) {
      const [sx, sy] = w2s(n.x, n.y);
      const sr = n.radius * zoom + 6 * zoom;
      ctx.beginPath();
      ctx.arc(sx, sy, sr, 0, Math.PI * 2);
      ctx.strokeStyle = '#fff5';
      ctx.lineWidth = 2 * zoom;
      ctx.stroke();
    }
    drawNode(n);
  }

  requestAnimationFrame(frame);
}

// ===== HELPERS =====
function esc(s) { if (s == null) return ''; const d = document.createElement('div'); d.textContent = String(s); return d.innerHTML; }
function kv(l, v) { return `<span class="kv-l">${esc(l)}</span><span class="kv-v">${esc(v)}</span>`; }
function formatNum(n) { return Number.isInteger(n) ? n.toLocaleString() : n.toLocaleString(undefined, { maximumFractionDigits: 4 }); }
function truncText(s, ctx, maxW) {
  if (ctx.measureText(s).width <= maxW) return s;
  while (s.length > 1 && ctx.measureText(s + '\u2026').width > maxW) s = s.slice(0, -1);
  return s + '\u2026';
}
function hexAlpha(a) {
  const v = Math.round(Math.max(0, Math.min(1, a)) * 255);
  return v.toString(16).padStart(2, '0');
}
function lighten(hex, amt) {
  const r = parseInt(hex.slice(1, 3), 16);
  const g = parseInt(hex.slice(3, 5), 16);
  const b = parseInt(hex.slice(5, 7), 16);
  return '#' + [r, g, b].map(c => Math.min(255, c + Math.round(amt * 255)).toString(16).padStart(2, '0')).join('');
}
function synHL(json) {
  return esc(json)
    .replace(/"([^"]+)":/g, '<span style="color:#5b7fff">"$1"</span>:')
    .replace(/: "([^"]*?)"/g, ': <span style="color:#34d399">"$1"</span>')
    .replace(/: (\d+\.?\d*)/g, ': <span style="color:#f59e0b">$1</span>')
    .replace(/: (true|false)/g, ': <span style="color:#a78bfa">$1</span>')
    .replace(/: (null)/g, ': <span style="color:#f472b6">$1</span>');
}

// Fade hint
setTimeout(() => { const h = document.getElementById('hint'); if (h) h.style.opacity = '0'; }, 6000);

// ===== START =====
requestAnimationFrame(frame);
load().catch(err => {
  const errNode = makeNode({ displayName: 'Error: ' + err.message, _isNs: true, uri: '' }, 0, 0, 0, null);
  nodes.push(errNode);
});
</script>
</body>
</html>